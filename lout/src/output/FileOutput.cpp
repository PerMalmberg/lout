// Copyright (c) 2016 Per Malmberg
// Licensed under MIT, see LICENSE file.
// Give credit where credit is due.

#include "output/FileOutput.h"
#include <iostream>
#include <sstream>


namespace lout {
namespace output {


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
FileOutput::FileOutput(std::shared_ptr<formatting::IFormatter> formatter, const std::string& pathToFile)
		: FileOutput( formatter, pathToFile, &std::cerr )
{
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
FileOutput::FileOutput(std::shared_ptr<formatting::IFormatter> formatter, const std::string& pathToFile, std::ostream* fallbackStream) :
		IOutput( formatter, fallbackStream ), myFilePath( pathToFile )
{
	// Open for output and append mode
	OpenFile();
	ReadFileSize();
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
FileOutput::~FileOutput()
{
	Close();
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void FileOutput::Close()
{
	try
	{
		if( myFile.is_open() )
		{
			myFile.close();
		}
	}
	catch( ... )
	{ }
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void FileOutput::Flush() noexcept
{
	try
	{
		if( myFile.is_open() )
		{
			myFile.flush();
		}
	}
	catch( ... )
	{ }
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void FileOutput::LogActual(const loglevel::ILogLevel& level, const std::string& msg)
{
	if( !Write( FormatForOutput( level, "", msg ) ) ) {
		FallbackLog(level, "", msg );
	}
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void FileOutput::LogWithCategoryActual(const loglevel::ILogLevel& level, const std::string& category,
                                       const std::string& msg)
{
	if( !Write( FormatForOutput( level, category, msg ) ) ) {
		FallbackLog(level, category, msg );
	}
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void FileOutput::OpenFile()
{
	if( !myFile.is_open()) {
		myFile.open( myFilePath, std::ios_base::out | std::ios_base::app );
	}
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
bool FileOutput::Write(const std::string& data)
{
	bool res = false;

	OpenFile();

	if( myFile.is_open() )
	{
		myFile << data << std::endl;
		ReadFileSize();
		res = true;
	}

	return res;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void FileOutput::ReadFileSize()
{
	if( myFile.good() && myFile.is_open() )
	{
		// Seek output to end of file
		myFile.seekp(0, std::ios_base::end);
		myCurrentSize = static_cast<long>( myFile.tellp() );
	}
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
std::string FileOutput::FormatForOutput(const loglevel::ILogLevel& level, const std::string& category,
                                        const std::string& msg)
{
	std::stringstream s;

	s << "[" << level;

	if( !category.empty() )
	{
		s << "/" << category;
	}

	s << "]" << msg;

	return s.str();
}

}
}
