// Copyright (c) 2016 Per Malmberg
// Licensed under MIT, see LICENSE file.
// Give credit where credit is due.

#include <lout/Lout.h>
#include <iostream>

namespace lout {

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
Lout::Lout()
		: myCurrentThreshold( 0, "NoLevel" ),
		  myActiveCategories(),
		  myPriorityCategories(),
		  myLock( std::make_shared<threading::NoLock>() )
{
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
Lout::~Lout()
{
	RemoveAllOutputs();
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void Lout::SetThreshold(const loglevel::ILogLevel& newLevel)
{
	myCurrentThreshold = newLevel;
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void Lout::ActivateCategory(const std::string& category)
{
	myActiveCategories.emplace( category );
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void Lout::ActivatePriorityCategory(const std::string& category)
{
	myPriorityCategories.emplace( category );
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void Lout::AddOutput(std::shared_ptr<output::IOutput> output)
{
	if( output )
	{
		myOutput.push_back( output );
	}
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void Lout::RemoveAllOutputs()
{
	FlushAll();
	Locker lock( myLock );
	(void)lock;
	myOutput.erase( myOutput.begin(), myOutput.end() );
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void Lout::Log(const loglevel::ILogLevel& level, const std::string& msg)
{
	Locker lock( myLock );
	(void)lock; // Just to silence the warning

	if( IsLevelActive( level ) )
	{
		for( auto& p : myOutput )
		{
			p.get()->Log( level, msg );
		}
	}
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void Lout::LogWithCategory(const loglevel::ILogLevel& level, const std::string& category, const std::string& msg)
{
	Locker lock( myLock );
	(void)lock;

	// First check level and normal categories. If no category is set, all are allowed.
	bool shallLog = IsLevelActive( level )
	                && (myActiveCategories.empty() || myActiveCategories.find( category ) != myActiveCategories.end());

	// Now check mandatory categories
	shallLog |= myPriorityCategories.find( category ) != myPriorityCategories.end();

	if( shallLog )
	{
		for( auto& p : myOutput )
		{
			p.get()->LogWithCategory( level, category, msg );
		}
	}
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void Lout::FlushAll()
{
	Locker lock( myLock );
	(void)lock;

	for( auto& p : myOutput )
	{
		(*p).Flush();
	}
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
Lout::Locker::Locker(std::shared_ptr<threading::ILock> lock)
		: myLock( lock )
{
	if( myLock )
	{
		myLock->Acquire();
	}
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
Lout::Locker::~Locker()
{
	if( myLock )
	{
		myLock->Release();
	}
}


} // END namespace lout