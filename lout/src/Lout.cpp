//
// Created by Per Malmberg on 2016-05-21.
//

#include <Lout.h>
#include <c++/iostream>

namespace lout {

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
Lout::Lout()
		: myCurrentThreshold( 0, "NoLevel" ),
		  myCurrentLoggingLevel( -1, "NoLevel" ),
		  myActiveCategories(),
		  myPriorityCategories()
{
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
Lout::~Lout()
{
	RemoveAllOutputs();
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void Lout::SetThreshold(const loglevel::ILogLevel& newLevel)
{
	myCurrentThreshold = newLevel;
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void Lout::ActivateCategory(const std::string& category)
{
	myActiveCategories.emplace( category );
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void Lout::ActivatePriorityCategory(const std::string& category)
{
	myPriorityCategories.emplace( category );
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void Lout::AddOutput(std::shared_ptr<output::IOutput> output)
{
	if( output )
	{
		myOutput.push_back( std::move( output ) );
	}
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void Lout::RemoveAllOutputs()
{
	FlushAll();
	myOutput.erase( myOutput.begin(), myOutput.end() );
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void Lout::Log(const loglevel::ILogLevel& level, const std::string& msg)
{
	if( IsLevelActive( level ) )
	{
		for( auto& p : myOutput )
		{
			try
			{
				p.get()->Log( level, msg );
			}
			catch( std::exception& e )
			{
				std::cerr << e.what() << std::endl;
			}
			catch( ... )
			{
				std::cerr << "Unknown error while logging" << std::endl;
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void Lout::LogWithCategory(const loglevel::ILogLevel& level, const std::string& category, const std::string& msg)
{
	// First check level and normal Categorys
	bool shallLog = IsLevelActive( level ) && myActiveCategories.find( category ) != myActiveCategories.end();
	// Now check mandatory Categorys
	shallLog |= myPriorityCategories.find( category ) != myPriorityCategories.end();

	if( shallLog )
	{
		for( auto& p : myOutput )
		{
			try
			{
				p.get()->LogWithCategory( level, category, msg );
			}
			catch( std::exception& e )
			{
				std::cerr << e.what() << std::endl;
			}
			catch( ... )
			{
				std::cerr << "Unknown error while logging" << std::endl;
			}
		}
	}
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
void Lout::FlushAll()
{
	for( auto& p : myOutput )
	{
		try
		{
			(*p).Flush();
		}
		catch( std::exception& e )
		{
			std::cerr << e.what() << std::endl;
		}
		catch( ... )
		{
			std::cerr << "Unknown error while flushing" << std::endl;
		}
	}
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
Lout& Lout::operator<<(int8_t value)
{
	Log( myCurrentLoggingLevel, std::to_string( value ) );
	return *this;
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
Lout& Lout::operator<<(int16_t value)
{
	Log( myCurrentLoggingLevel, std::to_string( value ) );
	return *this;
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
Lout& Lout::operator<<(int32_t value)
{
	Log( myCurrentLoggingLevel, std::to_string( value ) );
	return *this;
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
Lout& Lout::operator<<(int64_t value)
{
	Log( myCurrentLoggingLevel, std::to_string( value ) );
	return *this;
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
Lout& Lout::operator<<(uint8_t value)
{
	Log( myCurrentLoggingLevel, std::to_string( value ) );
	return *this;
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
Lout& Lout::operator<<(uint16_t value)
{
	Log( myCurrentLoggingLevel, std::to_string( value ) );
	return *this;
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
Lout& Lout::operator<<(uint32_t value)
{
	Log( myCurrentLoggingLevel, std::to_string( value ) );
	return *this;

}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
Lout& Lout::operator<<(uint64_t value)
{
	Log( myCurrentLoggingLevel, std::to_string( value ) );
	return *this;
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
Lout& Lout::operator<<(double value)
{
	Log( myCurrentLoggingLevel, std::to_string( value ) );
	return *this;
}


//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
Lout& Lout::operator<<(long double value)
{
	Log( myCurrentLoggingLevel, std::to_string( value ) );
	return *this;
}

//////////////////////////////////////////////////////////////////////////
//
//
//////////////////////////////////////////////////////////////////////////
Lout& Lout::operator<<(float value)
{
	Log( myCurrentLoggingLevel, std::to_string( value ) );
	return *this;
}


} // END namespace lout