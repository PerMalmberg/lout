// Copyright (c) 2016 Per Malmberg
// Licensed under MIT, see LICENSE file.
// Give credit where credit is due.

#include <iostream>
#include <lout/Lout.h>
#include <lout/threading/NoLock.h>
#include <utility>

namespace lout
{

	//////////////////////////////////////////////////////////////////////////
	//
	//
	//////////////////////////////////////////////////////////////////////////
	Lout::Lout() : myActiveCategories(), myPriorityCategories(), myLock(std::make_shared<threading::NoLock>())
	{
	}

	//////////////////////////////////////////////////////////////////////////
	//
	//
	//////////////////////////////////////////////////////////////////////////
	Lout::~Lout()
	{
		RemoveAllOutputs();
	}

	//////////////////////////////////////////////////////////////////////////
	//
	//
	//////////////////////////////////////////////////////////////////////////
	void Lout::SetThreshold(const loglevel::ILogLevel& newLevel)
	{
		Locker lock(myLock);
		(void)lock;

		for(auto p : myOutput)
		{
			p->SetThreshold(newLevel);
		}
	}

	//////////////////////////////////////////////////////////////////////////
	//
	//
	//////////////////////////////////////////////////////////////////////////
	void Lout::OverrideThreshold(std::shared_ptr<output::IOutput> output, const loglevel::ILogLevel& level)
	{
		Locker lock(myLock);
		(void)lock;
		output->SetThreshold(level);
	}

	//////////////////////////////////////////////////////////////////////////
	//
	//
	//////////////////////////////////////////////////////////////////////////
	void Lout::ActivateCategory(const std::string& category)
	{
		Locker lock(myLock);
		(void)lock;

		myActiveCategories.emplace(category);
	}

	//////////////////////////////////////////////////////////////////////////
	//
	//
	//////////////////////////////////////////////////////////////////////////
	void Lout::ActivatePriorityCategory(const std::string& category)
	{
		Locker lock(myLock);
		(void)lock;

		myPriorityCategories.emplace(category);
	}

	//////////////////////////////////////////////////////////////////////////
	//
	//
	//////////////////////////////////////////////////////////////////////////
	void Lout::AddOutput(std::shared_ptr<output::IOutput> output)
	{
		Locker lock(myLock);
		(void)lock;

		if(output)
		{
			myOutput.push_back(output);
		}
	}

	//////////////////////////////////////////////////////////////////////////
	//
	//
	//////////////////////////////////////////////////////////////////////////
	void Lout::RemoveAllOutputs()
	{
		FlushAll();
		Locker lock(myLock);
		(void)lock;
		myOutput.erase(myOutput.begin(), myOutput.end());
	}

	//////////////////////////////////////////////////////////////////////////
	//
	//
	//////////////////////////////////////////////////////////////////////////
	void Lout::Log(const time_t& timestamp, const loglevel::ILogLevel& level, const std::string& msg)
	{
		Locker lock(myLock);
		(void)lock;

		for(auto& p : myOutput)
		{
			if(p->IsLevelActive(level))
			{
				p.get()->Log(timestamp, level, msg);
			}
		}
	}

	//////////////////////////////////////////////////////////////////////////
	//
	//
	//////////////////////////////////////////////////////////////////////////
	void Lout::LogWithCategory(const time_t& timestamp,
	                           const loglevel::ILogLevel& level,
	                           const std::string& category,
	                           const std::string& msg)
	{
		Locker lock(myLock);
		(void)lock;

		// First check normal categories. If no category is set, all are allowed.
		bool shallLog = myActiveCategories.empty() || myActiveCategories.find(category) != myActiveCategories.end();

		// Now check priority categories
		bool priority = myPriorityCategories.find(category) != myPriorityCategories.end();

		if(shallLog || priority)
		{
			for(auto& p : myOutput)
			{
				// The message should be logged if a priority category is used, or if the output has the level active.
				if(priority || p->IsLevelActive(level))
				{
					p.get()->LogWithCategory(timestamp, level, category, msg);
				}
			}
		}
	}

	//////////////////////////////////////////////////////////////////////////
	//
	//
	//////////////////////////////////////////////////////////////////////////
	void Lout::ClearLog() const
	{
		Locker lock(myLock);
		(void)lock;

		for(auto& p : myOutput)
		{
			p.get()->Clear();
		}
	}

	//////////////////////////////////////////////////////////////////////////
	//
	//
	//////////////////////////////////////////////////////////////////////////
	void Lout::FlushAll()
	{
		Locker lock(myLock);
		(void)lock;

		for(auto& out : myOutput)
		{
			(*out).Flush();
		}
	}

	//////////////////////////////////////////////////////////////////////////
	//
	//
	//////////////////////////////////////////////////////////////////////////
	Lout::Locker::Locker(std::shared_ptr<threading::ILock> lock) : myLock(std::move(lock))
	{
		if(myLock)
		{
			myLock->Acquire();
		}
	}

	//////////////////////////////////////////////////////////////////////////
	//
	//
	//////////////////////////////////////////////////////////////////////////
	Lout::Locker::~Locker()
	{
		if(myLock)
		{
			myLock->Release();
		}
	}

} // END namespace lout
